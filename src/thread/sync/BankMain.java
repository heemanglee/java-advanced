package thread.sync;

import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class BankMain {

    public static void main(String[] args) throws InterruptedException {
//        BankAccount bankAccount = new BankAccountV1(1000); // 계좌 초기 잔액은 1000원이다.
//        BankAccount bankAccount = new BankAccountV2(1000); // 계좌 초기 잔액은 1000원이다.
        BankAccount bankAccount = new BankAccountV3(1000); // 계좌 초기 잔액은 1000원이다.

        Thread t1 = new Thread(new WithdrawTask(bankAccount, 800), "t1");
        Thread t2 = new Thread(new WithdrawTask(bankAccount, 800), "t2");
        t1.start();
        t2.start();

        sleep(500);
        log("t1 state: " + t1.getState());
        log("t2 state: " + t2.getState());

        t1.join();
        t2.join();
        log("최종 잔액: " + bankAccount.getBalance());

        // 임계 영역을 설정하지 않고 공유 변수에 여러 스레드가 동시에 접근하게 한 경우의 출력 결과
        /*
         * 13:37:46.704 [       t2] 거래 시작: BankAccountV1
         * 13:37:46.704 [       t1] 거래 시작: BankAccountV1
         * 13:37:46.710 [       t1] [검증 시작] 출금액 : 800, 현재 잔액 : 1000
         * 13:37:46.711 [       t1] [검증 완료] 출금액 : 800, 현재 잔액 : 1000
         * 13:37:46.712 [       t2] [검증 시작] 출금액 : 800, 현재 잔액 : 1000
         * 13:37:46.712 [       t2] [검증 완료] 출금액 : 800, 현재 잔액 : 1000
         * 13:37:47.181 [     main] t1 state: TIMED_WAITING
         * 13:37:47.181 [     main] t2 state: TIMED_WAITING
         * 13:37:47.716 [       t1] [출금 완료] 출금액 : 800, 현재 잔액 : 200
         * 13:37:47.717 [       t1] 거래 종료
         * 13:37:47.719 [       t2] [출금 완료] 출금액 : 800, 현재 잔액 : -600
         * 13:37:47.720 [       t2] 거래 종료
         * 13:37:47.725 [     main] 최종 잔액: -600
         */

        // t1 스레드와 t2 스레드는 동일한 BankAccountV1 인스턴스를 사용한다. -> BankAccountV1은 "공유변수"
        // t2 스레드가 먼저 시작되었고, 계좌에 남은 잔액을 먼저 확인한 스레드는 t1이다.
        // t1 스레드가 출금하기 전에 t2 스레드가 계좌의 잔액을 확인했으므로 검증에 성공한다.
        // 두 스레드 모두 검증에 성공한 상태이기 때문에 출금을 시도한다.
        // t1 스레드가 먼저 출금하여 (1000 - 800)을 하여 잔액이 200원이 남은 상태가 되었다.
        // 이어서 t2 스레드가 출금을 완료하였다. -> 여기서 문제는 t2 스레드가 출금 후 계좌에 남은 잔액이 "-600"인 것이다.
        // 분명 검증 로직에 "현재 잔액 < 출금할 잔액"이면 출금을 못하게 막았으나 정상적으로 출금 처리가 되었다.
        // 이러한 이유가 발생한 이유는 t1 스레드가 출금하기 이전에 t2 스레드가 계좌에 남은 잔액을 읽었기 때문이다.
        // t2 스레드가 계죄의 잔액을 읽었을 당시에는 "현재 잔액 > 출금할 잔액" 이였으므로 문제가 발상하지 않았다.

        // -------------------------------------------------------------------------------

        // 메서드에 임계 영역을 설정 후 출력 결과
        /*
         * 14:55:13.241 [       t1] 거래 시작: BankAccountV2
         * 14:55:13.247 [       t1] [검증 시작] 출금액 : 800, 현재 잔액 : 1000
         * 14:55:13.247 [       t1] [검증 완료] 출금액 : 800, 현재 잔액 : 1000
         * 14:55:13.726 [     main] t1 state: TIMED_WAITING
         * 14:55:13.727 [     main] t2 state: BLOCKED
         * 14:55:14.253 [       t1] [출금 완료] 출금액 : 800, 현재 잔액 : 200
         * 14:55:14.254 [       t1] 거래 종료
         * 14:55:14.255 [       t2] 거래 시작: BankAccountV2
         * 14:55:14.255 [       t2] [검증 시작] 출금액 : 800, 현재 잔액 : 200
         * 14:55:14.256 [       t2] [검증 실패] 출금액 : 800, 현재 잔액 : 200
         * 14:55:14.261 [     main] 최종 잔액: 200
         */

        // BankAccountV2에서는 공유 변수를 접근하는 "메서드"에 임계 영역을 설정하였다.
        // 임계 영역이란 "공유 변수"에 "여러 스레드가 동시에" 접근하지 못하도록 보장한다.
        // 자바에서는 "synchronized" 키워드를 사용하여 임계 영역을 설정할 수 있다.
        // 임계 영역에 접근하기 위해서는 인스턴스가 가지고 있는 "lock"을 획득해야 하고, 사용을 완료한 스레드는 "lock"을 반환해야 한다.

        // 위 출력 결과를 보면 withdraw() 메서드에 임계 영역을 설정하였기 때문에 t1, t2 스레드가 동시에 메서드에 접근하지 못한다.
        // t1 스레드가 먼저 lock을 획득하여 임계 영역에 접근하였고, 이후에 t2 스레드가 임계 영역에 접근하고자 하였을 때 lock이 없기 때문에 "RUNNABLE -> BLOCKED" 상태가 된다.
        // 이후에 t1 스레드의 작업이 모두 종료되고 lock을 반환하면 t2 스레드는 lock을 획득하여 작업을 시작한디. t2 스레드는 "BLOCKED -> RUNNABLE" 상태가 된다.
        // t2 스레드가 작업을 시작 후, balance 변수를 읽으면 200이 저장되어 있기 때문에 검증에서 실패하게 된댜.

        // -------------------------------------------------------------------------------

        // 공유 변수에 접근하는 코드 영역에만 임계 영역을 설정 후 출력 결과
        /*
         * 15:12:17.758 [       t2] 거래 시작: BankAccountV3
         * 15:12:17.758 [       t1] 거래 시작: BankAccountV3
         * 15:12:17.764 [       t2] [검증 시작] 출금액 : 800, 현재 잔액 : 1000
         * 15:12:17.764 [       t2] [검증 완료] 출금액 : 800, 현재 잔액 : 1000
         * 15:12:18.246 [     main] t1 state: BLOCKED
         * 15:12:18.247 [     main] t2 state: TIMED_WAITING
         * 15:12:18.770 [       t2] [출금 완료] 출금액 : 800, 현재 잔액 : 200
         * 15:12:18.772 [       t2] 거래 종료
         * 15:12:18.772 [       t1] [검증 시작] 출금액 : 800, 현재 잔액 : 200
         * 15:12:18.773 [       t1] [검증 실패] 출금액 : 800, 현재 잔액 : 200
         * 15:12:18.779 [     main] 최종 잔액: 200
         */

        // BankAccountV2의 경우 메서드에 임계 영역을 설정하였는데, 이는 메서드 내부의 모든 코드에 대해서 임계 영역을 설정하게 된다.
        // 이는 여러 스레드가 동시에 접근해도 되는 코드에도 동시에 접근하지 못화도록 하는 것인데, 이는 성능상 매우 불리해진다.
        // 따라서 BankAccountV3에서는 공유 변수를 접근하는 코드 영역에만 임계 영역을 설정하여, 여러 스레드가 동시에 접근해도 되는 영역에는 접근할 수 있도록 하였다.

        // V2와 V3의 출력 결과를 보면, V2의 경우 t1 스레드가 작업을 모두 마쳐야 t2 스레드가 거래를 시작하였고,
        // V3의 경우 t1, t2 스레드가 일단 동시에 거래를 시작하고, 공유 변수에 접근하는 영역에는 lock을 먼저 획득한 스레드가 작업을 먼저 시작할 수 있도록 하였다.

        // 여기서 중요한 점은 "임계 영역 범위를 최소화하여" 처리 성능을 높여야한다는 것이다.

    }

}
